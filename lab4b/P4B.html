<HTML>
<HEAD>
<TITLE>Project 4B</TITLE>
</HEAD>
<BODY>
<CENTER>
<H1>Project 4B<br>
Sensors Input</H1>
</CENTER>

<H2>INTRODUCTION:</H2>
<P>
One of the things that makes small, low-power-consumption
systems interesting is ability they give us to create software
that interacts with people in the physical world.
The input side of those interactions is via a variety of local sensors
(e.g., for sound, light, temperature, position, motion, pressure).
The output side can be sensory (e.g., sound, lights, low power displays)
or physical (e.g. mechanical actuators), or (through digital and
analog outputs) any other controllable device.
Building interactive personal appliances requires us to be able to
communicate with the types of sensors, indicators and actuators that
can be connected to such systems.  Such devices have become increasingly 
popular and common in recent years.
</P>
<P>
In this project we will create applications that run in an embedded system,
read data from external sensors, and log the results.  Real world 
devices of this kind are commonly networked.  We'll take that step in Project 4C. For now, the device you build will be stand-alone.
</P>

<H2>RELATION TO READING AND LECTURES:</H2>
<P>
This project is an introductory exploration of technologies and services not 
covered in the reading and lectures.
</P>

<H2>PROJECT OBJECTIVES:</H2>
<UL>
    <LI> Primary: Demonstrate the ability to design, build and debug interactive 
    	applications on an embedded system.</LI>
    <LI> Primary: Develop the ability to work with embedded system sensors and actuators
         through standard tool kits.</LI>
    <LI> Primary: Gain experience with the processing of digital and analog inputs
    	 on an embedded system.</li>
</UL>

<H2>DELIVERABLES:</H2>
A single compressed tarball (<tt>.tar.gz</tt>) containing:
<UL>
    <LI> C source files for an embedded application that builds and runs (with no errors
     	or warnings) on an embedded system
    <li> A <tt>Makefile</tt> to build and test your application.
	 The higher level targets should include:
	<ul>
		<li>default ... build your program
		    (compiling with the <strong><tt>-Wall</tt></strong> and 
		    <strong><tt>-Wextra</tt></strong> options).
		    </li>
		<li><strong>check</strong> ... execute an automated smoke-test of your
			application to see if it runs and can talk to its sensors.</li>
		<li><strong>clean</strong> ... delete all programs and output generated by the Makefile</li>
		<li><strong>dist</strong> ... (runnable on a Linux desktop or server) create the deliverable tarball</li>
	</ul></li>
    	Note that this <tt>Makefile</tt> is intended to be executed on an embedded system
    <li> a <tt>README</tt> file containing:
	<ul>
		<li> descriptions of each of the included files</li>
		<li> any other comments on your submission 
			that you would like to bring to our attention 
	 		(e.g., research, limitations, features, testing methodology).</LI>
	</ul></li>
</UL>

<H2>PREPARATION:</H2>
<P>
<ul>
   <li> If you have not already done so, look at the documentation for the
	<A href="http://man7.org/linux/man-pages/man2/poll.2.html">poll(2)</A>
	system call 
	or the <tt>O_NONBLOCK</tt> option used with the
	<A href="http://man7.org/linux/man-pages/man2/open.2.html">open(2)</A>
	system call or
	<A href="http://man7.org/linux/man-pages/man2/fcntl.2.html">fcntl(2)</A>
	<TT>F_SETFL</tt> operation.
   <li> Read the documentation on the 
   	<A href="http://wiki.seeed.cc/Grove-Temperature_Sensor_V1.2">Grove Temperature Sensor</A>,
	and the algorithm for converting a reading into a temperature.</li>
   <li> Review the documentation for the
   	<a href="https://iotdk.intel.com/docs/master/mraa/">MRAA</A>
	library, an open source, platform independent library for embedded system I/O. (The MRAA page does not explicitly list the Beaglebone
Green Wireless, the device you will be using, as supported, but it is supported.) 
	Also read the
	<a href="https://drive.google.com/drive/folders/0B6dyEb8VXZo-N3hVcVI0UFpWSVk">General Purpose and Analog I/O</A> 
	tutorial that discusses the particular classes you will be using.  These classes include the functions you will be using to read from
	the temperature sensor and button.  
	(Note that to link with this library you will have to add <tt>-lmraa</tt> 
	 to your library search list).
   <li> Read the instructions that came with your Grove Starter Kit.
        They include information on all of your sensors and instructions on
	where to plug each in to the Base Shield.</li>
   <li>	Attach your Grove Base Shield 
   	(a plug-on daughter-board with connectors for all of your sensors) to your embedded system.</li>
   <li> Attach your Grove Temperature Sensor to the Analog A0/A1 connector on your Grove cape,
   	where it will be addressed as I/O pin #1.</li>
   <li> Attach your Grove Button to the GPIO_50 connector on your Grove cape,
   	where it will be addressed as I/O pin #60.</li>
   <li> The calibration constants for converting thermometer readings into 
     	temperatures depend on the Grove cape voltage switch being set to 5 volts.
   <li> Power-up your embedded system and confirm that you can still log in and transfer files to it.</li>
</ul>
</P>

<H2>PROJECT DESCRIPTION:</H2>
<P>
Write a program (called <tt>lab4b</tt>) that:
<ul>
   <li> builds and runs on your embedded system.</li>
   <li> uses the AIO functions of the MRAA library to get readings from your temperature sensor.</li>
   <li>	samples a temperature sensor at a configurable rate (defaulting to 1/second, and controlled
   	by an optional <tt>--period=</tt># command line parameter that specifies a sampling 
	interval in seconds).</li>
   <li> converts the sensor value into a temperature.  By default, temperatures should be
        reported in degrees Fahrenheit, but this can be controlled with an optional
	<tt>--scale=C</tt> (or <tt>--scale=F</tt>) command line parameter.</li>
   <li> creates a report for each sample that includes:
   	<ul>
	   <li>	time of the sample (e.g. <tt>17:25:58</tt>) in the local timezone</li>
	   <li> a single blank/space</li>
	   <li> a decimal temperature in degrees and tenths (e.g. <tt>98.6</tt>)
	   <li> a newline character (<em>\n</em>)
	</ul></li>
   <li> writes that report to the stdout (fd 1).</li>
   <li> appends that report to a logfile (which it creates on your embedded system) if that logging has been enabled
   	with an optional <tt>--log=</tt><em>filename</em> parameter.</li>
   <li> uses the GPIO functions of the MRAA library to samples the state of the button 
   	(from your Grove sensor kit) and when it is pushed ...
   	<ul>
	   <li> outputs (and logs) a final sample with the time and the string <tt>SHUTDOWN</tt> 
	   	(instead of a temperature).</li>
	   <li> exits</li>
	</ul>
   </li>
   <li> Your program can assume that the sensors are connected as recommended by the Grove
        documentation.
   </li>
</ul>
</p>
<P>
Note that we want you to use MRAA AIO/GPIO functions to access your sensors, and not the (more powerful
and convenient) Grove library functions.  The Grove library hides all of the details of embedded I/O, 
sampling and signal interpretation, but only works for the Grove Sensors.  
We want you to get experience with direct control of and access to the digital and analog I/O pins.
</P>
<P>
Many people have observed that the recommended calibration constants appear to be off by
ten degrees or more.  Every sensor (including the ones that will be used when we grade your submissions)
seems to read differently.
</p>
<P>
The time returned from <em>localtime(3)</em> will only be in the correct timezone if you have
correctly configured the local timezone on your embedded system.
</P>
Extend your program to (in parallel with generating reports) accept the following commands from stdin:
<ul>
   <li> <tt><strong>SCALE=F</strong></tt><br>
   	This command should cause all subsequent reports to be generated in degrees Fahrenheit.
   </li>
   <li> <tt><strong>SCALE=C</strong></tt><br>
   	This command should cause all subsequent reports to be generated in degrees Centegrade
   </li>
   <li> <tt><strong>PERIOD=</strong></tt><em>seconds</em><br>
   	This command should change the number of seconds between reporting intervals.
	It is acceptable if this command does not take effect until after the next
	report.
   </li>
   <li> <tt><strong>STOP</strong></tt><br>
   	This command should cause the program to stop generating reports, but continue
	processing input commands.
	If the program is not generating reports, merely log receipt of the command.
   </li>
   <li> <tt><strong>START</strong></tt><br>
   	This command should cause the program to, if stopped, resume generating reports.
	If the program is not stopped, merely log receipt of the command.
   </li>
   <li> <strong><tt>LOG</tt></strong> <em>line of text</em><br>
     	This command requires no action beyond logging its receipt
	(the entire command, including the <tt>LOG</tt>).
        In project 4C, the server may send such commands to help 
	you debug problems with your reports.
   </li>
   <li> <tt><strong>OFF</strong></tt><br>
   	This command should, like pressing the button, output (and log) a time-stamped <tt>SHUTDOWN</tt> message 
	and exit.
   </li>
</ul>
<P>
All received commands will be terminated by a new-line character ('<em>\n</em>').
Note that when your program is tested (by the sanity checker or grading program)
stdin will not be a console, but a pipe.  
A single read may return a partial line or multiple lines.
Make sure that your program buffers and lexes its input,
and does not assume that one call to <em>read(2)</em> will return one command.
</P>
<P>
Nothing special needs to be done about strange combinations of commands:
<UL>
   <li> a <tt>START</tt> when you are already started is a no-op.</li>
   <li> a <tt>STOP</tt> when you are already stopped is a no-op.</li>
   <li> it is not expected that a <tt>STOP</tt>, <tt>PERIOD</tt>,
   	or <tt>SCALE</tt> command
        will force out a report whose time as not yet come.</li>
</UL>
</P>
<P>
If logging is enabled, all received commands (valid or not)
should be appended to the log file (exactly as
received, with no timestamp) but not displayed to standard output.  A sample log is 
shown below:
</p>
<pre><tt>
	11:37:41 98.6
	11:37:42 98.6
	11:37:43 98.6
	PERIOD=5
	11:37:44 98.6
	11:37:49 98.6
	11:37:54 98.6
	SCALE=C
	11:37:59 37.0
	11:38:04 37.0
	STOP
	START
	11:38:19 37.0
	11:38:24 37.0
	OFF
	11:38:27 SHUTDOWN
</tt></pre>
<P>
If you are typing commands to your program, you may see the echos interspersed with 
temperature reports.  This is unimportant, because they should be correctly distinct
in your log, and when we test your submission, the input will becoming from a program
rather than a console.
</P>
<P>
The sanity check script will send a series of commands to your program, and some
implementations process all the commands before generating any reports.  To make
sure this doesn't happen, you should generate your first report before you start
processing input commands.  Again, this will not be an issue during testing because
there will be delays between the commands when we test your program.
</P>
<P>
You could implement this program with separate threads for sensor polling and command processing,
but the computation associated with each operation is so small that you may find it much simpler
to use a single thread (and polling or non-blocking I/O) to avoid hanging on standard input for
commands that only rarely arrive.  A poll system call cannot tell you that the button has
been pushed, but GPIO pin read is a non-blocking operation, so you can simply read the button
status periodically.  If your interval between reads is too long, the button may be pressed
and released before you can read its status.  To avoid this problem, you can either use
a short polling interval or arrange for an interrupt/signal when the button is pushed.
</P>
<P>
To facilitate development and testing you might find it helpful to write your program to support a 
(<tt>-DDUMMY</tt>) define whose special code includes mock implementations for the <tt>mraa_aio_</tt> and 
<tt>mraa_gpio_</tt> functionality. Doing so will enable you to do most of your testing on your regular computer.  
When you are satisfied that it works there, modify your Makefile, run the command "<tt>uname -r</tt>", and check for the 
presence of the string "<tt>beaglebone</tt>" in the resulting output. If it is not found, build with a rule
that passed the <tt>-DDUMMY</tt> flag to <em>gcc</em>.
</p>

<H2>SUBMISSION:</H2>
<p>
Your tarball should have a name of the form <tt>lab4b-</tt><em>studentID</em><tt>.tar.gz</tt>.
You can sanity check your submission with this 
<A href="P4B_check.sh">test script</A>.  
It should run on an embedded system, but if your program is (as above) runnable on your Linux
development system, the sanity check script should also run there.
There will be no manual re-grading on this project.
Submissions that do not pass the test script are likely to receive very low scores.
</p>
<P>
Your <strong>README</strong> file (and all source files) must include lines of the form:
<ul>
	<strong>NAME:</strong> <em>your name</em><br>
	<strong>EMAIL:</strong> <em>your email</em><br>
	<strong>ID:</strong> <em>your student ID</em>
</ul>
And, if slip days are allowed on this project, and you want to use some,
this too must be included in the <strong>README</strong> file:
<ul>
	<strong>SLIPDAYS:</strong> <em>#days</em>
</ul>
If, for instance, you wanted to use two slip-days, you would add the following
line:
<ul>
	<strong>SLIPDAYS: 2</strong>
</ul>
</P>

<H2>GRADING:</H2>
<P>
Points for this project will be awarded:
</P>
<div align="center">
<table><tbody>
<tr> <th>value</th>	<th align="left">feature</th></tr>

<tr> <td></td>		<th align="left">Packaging and build (10% total)</th></tr>
<tr> <td>3%</td>	<td>un-tars expected contents</td></tr>
<tr> <td>3%</td>	<td>clean build of correct program w/default action (no warnings)</td></tr>
<tr> <td>2%</td>	<td>Makefile has working <tt>clean</tt>, <tt>check</tt>, <tt>dist</tt> targets</td></tr>
<tr> <td>2%</td>	<td>reasonableness of <tt>README</tt> contents</td></tr>

<tr> <td></td> </tr>
<tr> <td></td>		<th align="left">Sensor Functionality (25% total)</th></tr>
<tr> <td>10%</td>	<td>samples and reports temperature</td></tr>
<tr> <td>5%</td>	<td>reports Fahrenheit temperature (by default)</td></tr>
<tr> <td>5%</td>	<td>reports Centegratde temperature (w/<tt>--scale=</tt> parameter)</td></tr>
<tr> <td>5%</td>	<td>samples button and exits</td></tr>

<tr> <td></td> </tr>
<tr> <td></td>		<th align="left">Control Functionality (40% total)</th></tr>
<tr> <td>10%</td>	<td>command and data logging</td</tr>
<tr> <td>10%</td>	<td><tt>START</tt>/<tt>STOP</tt> commands</td></tr>
<tr> <td>10%</td>	<td><tt>PERIOD=</tt><em>#</em> command</td></tr>
<tr> <td>5%</td>	<td><tt>SCALE=C</tt>/<tt>F</tt> commands</td></tr>
<tr> <td>5%</td>	<td><tt>OFF</tt> command</td></tr>

<tr> <td></td> </tr>
<tr> <td></td>		<th align="left">Code Review (25%)</th></tr>
<tr> <td>10%</td>	<td>use of AIO functions to read temperature</td></tr>
<tr> <td>10%</td>	<td>use of GPIO functions to read button</td></tr>
<tr> <td>5%</td>	<td>general readability and understandability</td></tr>
</tbody></table>
</div>

</BODY>
</HTML>
